\subsubsection{\textit{Analisi dei Requisiti}}
L’\textit{Analisi dei Requisiti} è un’attività fondamentale che precede la progettazione. 
Si concretizza nel documento \textit{Analisi dei Requisiti}. Lo scopo di quest’attività è:
    \begin{itemize}
        \item Definire le funzionalità che il prodotto\textsubscript{g} andrà ad offrire;
        \item Porre le basi per la fase di progettazione del software;
        \item Fare una stima della mole di lavoro;
        \item Facilitare la verifica\textsubscript{g}. 
    \end{itemize}

\paragraph{Struttura del documento} Il documento è strutturato nel modo seguente:
    \begin{itemize}
        \item \textbf{Introduzione}: contiene una breve descrizione del documento e specifica gli attori dei casi d’uso;
		\item \textbf{Casi d’uso}: vengono specificati i casi d’uso individuati;
		\item \textbf{Requisiti}: sono classificati i requisiti che il prodotto\textsubscript{g} finale dovrà soddisfare.
    \end{itemize}

\paragraph{Casi d’uso} 

I casi d’uso sono identificati seguendo la seguente struttura:

\begin{center}\textbf{UC [Numero caso d’uso].[Numero sottocaso d’uso]-[Titolo caso d’uso]}\end{center}

\noindent Vengono poi indicati:
    \begin{itemize}
        \item \textbf{Diagramma UML\textsubscript{g}}: viene mostrato il diagramma solo per i casi più complessi, in cui è ritenuto necessario per una maggiore comprensione. Per i casi d’uso facoltativi il diagramma è colorato di azzurro (non standard UML\textsubscript{g}) per una maggiore differenziazione;
	    \item \textbf{Attore\textsubscript{g} primario}: utente esterno al sistema che svolge il caso d’uso;
	    \item \textbf{Descrizione}: breve descrizione del caso d’uso;
	    \item \textbf{Precondizioni}: indica la condizione del sistema prima del verificarsi del caso d’uso;
	    \item \textbf{Postcondizioni}: indica la condizione del sistema dopo che si è verificato il caso d’uso;
	    \item \textbf{Scenario principale}: descrive l’interazione tra l’attore\textsubscript{g} primario e il sistema;
	    \item \textbf{Estensioni}: casi d’uso alternativi che possono verificarsi al posto di quello a cui sono collegati. 
    \end{itemize}

\paragraph{Requisiti} 
I requisiti sono classificati secondo la seguente struttura: 

\begin{center}\textbf{R.[Tipologia][Numero seriale]}\end{center}

\noindent con:
    \begin{itemize}
        \item \textbf{Tipologia}: 
            \begin{itemize}
                \item \textbf{F}: funzionale;
                \item \textbf{Q}: qualitativo;
                \item \textbf{D}: di dominio;
                \item \textbf{P}: prestazionale.
            \end{itemize}
	    \item \textbf{Descrizione}: breve descrizione del requisito;
	    \item \textbf{Classificazione}: un requisito può essere facoltativo o obbligatorio;
	    \item \textbf{Fonti}: possono essere: 
            \begin{itemize}
                \item Casi d’uso;
                \item Capitolato;
                \item Decisione interna.
            \end{itemize}
    \end{itemize}

\subsubsection{Progettazione} 
L’attività di progettazione è assegnata ai progettisti. Seguendo quanto indicato 
nell’\textit{Analisi dei Requisiti}, l’obiettivo è quello di progettare l’architettura del sistema, 
prima con la creazione di un Proof of Concept\textsubscript{g} per la Requirments and Tecnology Baseline e poi andando 
nel dettaglio per la Product Baseline.

\paragraph{Requirments and Tecnology Baseline} 
In questa fase vengono fissati i requisiti che il gruppo si impegna a soddisfare, in accordo con il 
proponente\textsubscript{g}; si studiano le tecnologie, i framework\textsubscript{g} e le librerie utili alla realizzazione del 
prodotto\textsubscript{g} finale e si crea di conseguenza un Proof of Concept\textsubscript{g}. I materiali da mostrare sono:
    \begin{itemize}
        \item Tecnologie, framework\textsubscript{g}, librerie utilizzate, motivando la scelta;
        \item Proof of Concept\textsubscript{g};
        \item \textit{Analisi dei Requisiti}.
    \end{itemize}
La documentazione da mostrare:
    \begin{itemize}
        \item \textit{Piano di Progetto};
        \item \textit{Piano di Qualifica};
        \item \textit{Norme di Progetto};
        \item \textit{Verbali} interni ed esterni.
    \end{itemize}

\subsubsection{Codifica}
L’attività di codifica è assegnata ai programmatori. Seguendo quanto indicato nel diagramma delle classi, l'obbiettivo è quello di implementare ciò che è stato precedentemente progettato.
La codifica dovrà rispettare delle norme per motivi legati alla leggibilità, manutenzione, verifica e validazione del codice.
\paragraph{Stile di codifica}
	\begin{itemize}
		\item \textbf{Indentazione}: I blocchi di codice innestati dovranno avere un’indentazione di quattro spazi;
		\item \textbf{Parentesi graffe}:La parentesi aperta dovrà essere inserita nella stessa riga di dichiarazione del costrutto, separata da uno spazio, mentre la parentesi chiusa dovrà essere inserita con la giusta indentazione alla riga immediatamente successiva all’ultima riga di codice del costrutto;
		\item \textbf{Metodi}: il nome dei metodi dovrà iniziare con lettera minuscola e, se composto da più parole,
			le successive dovranno iniziare con lettera maiuscola. E preferibile mantenere metodi brevi, con
			poche righe di codice; 
		\item \textbf{Classi}: il nome delle classi dovrà sempre iniziare con la lettera maiuscola e, come per i metodi,
			se composto da più parole, le successive dovranno iniziare con la lettere maiuscola;
		\item \textbf{Variabili}: il nome delle variabili deve sempre essere scritto in minuscolo e in inglese e la loro dichiarazione possibilmente all'inizio della funzione o script. Se il nome è composto da più parole, la seconda dovrà iniziare con la lettera maiuscola;
		\item \textbf{Costanti}: il nome deve essere sempre scritto in maiuscolo e in inglese. Se il nome è composto da più parole, queste dovranno essere separate dal carattere ’ \textunderscore’;
		\item \textbf{Univocità dei nomi}: tutti i costrutti dovranno avere nomi univoci e significativi;
		\item \textbf{Commenti}: i commenti dovranno essere inseriti prima dell’inizio del costrutto e presentati in lingua italiana, inoltre sono obbligatori in parti di codice che non sono immediatamente comprensibili. Ogni volta che viene aggiornato un metodo va verificata la validità del commento;
		\item \textbf{File}: dovranno avere un nome che inizia per lettera maiuscola che ne specifichi il contenuto.
	\end{itemize}
	
	\paragraph{Norme linguaggi adottati} 
 	In questo paragrafo andremo a definire le norme che il gruppo ha deciso di adottare per ogni specifico linguaggio utilizzato nel progetto.
	\subparagraph*{HTML} è oggi utilizzato per creazione della struttura logica di una pagina web,abbiamo 	 deciso di adottare le seguenti semplici normative:
	\begin{itemize}
	\item Utilizzare tag lowercase;
	\item Chiudere tutti i tag;
	\item Utilizzare attributi dei tag in lowercase;
	\item Utilizzare le virgolette per i valori degli attributi.
	\end{itemize}	
	
	\subparagraph*{CSS} linguaggio che gestisce il design e la presentazione delle pagine web. \\
	Il gruppo ha concordato le seguenti normative:
	\begin{itemize}
	\item Un solo selettore per linea in set di regole con più selettori;
	\item Un singolo spazio prima della parentesi graffa di apertura di un set di regole;
	\item Una dichiarazione per linea di un blocco dichiarazioni;
	\item  Un livello di rientro per ogni dichiarazione;
	\item Un singolo spazio dopo i due-punti di una dichiarazione;
	\item Includete sempre un “punto e virgola” alla fine dell'ultima dichiarazione in un blocco dichiarazione;
	\item Mettete la parentesi graffa di chiusura di un set di regole, nella stessa colonna del primo carattere del set di regole;
	\item Separate ogni set di regole con una linea vuota.
	\end{itemize}
	
	\subparagraph*{JavaScript}  è un linguaggio di programmazione multi paradigma orientato agli eventi, utilizzato sia nella programmazione lato client web che lato server. \\
Il gruppo ha deciso di adottare lo stile di codifica presente al seguente link:
\begin{center}
\href{https://github.com/airbnb/javascript}{https://github.com/airbnb/javascript(21-04-2023)}
\end{center}

\paragraph{Norme React.js}
	Il gruppo ha concordato le seguenti normative:
	\begin{itemize}
	\item Il nome del componente deve essere uguale al nome del modulo con la prima lettera maiuscola;
	\item Scrittura di informazioni dentro ad un tag;
		\begin{itemize}
			\item Se l’informazione può essere contenuta in una linea di codice allora si mantiene sulla stessa ;		linea
			\item Se l’informazione è più lunga di una linea di codice allora bisogna indentare le informazioni.
		\end{itemize}
		\item Utilizzare sempre camelCase per i nomi delle prop;
		\item Utilizzare i doppi apici tranne che per i valori nelle informazioni di stile;
		\item Utilizzare una self-close se i tag non hanno figli;
		\item Utilizzare className per assegnare classi CSS agli elementi;
		\item Non comprimere troppo il codice ma utilizzare degli whitespace adeguati.
	\end{itemize}
	
	\paragraph{Organizzazione Codice}
	Il codice deve essere organizzato secondo la struttura chiama \textit{Feature Folders} raccomandata dalle linee guida di Redux.\\
	In seguito riportiamo la struttura che il gruppo ha deciso di utilizzare per il progetto:
	\begin{itemize}
		\item \textbf{\textbackslash public}
			\begin{itemize}
				\item \textbf{index.html} 
			\end{itemize}
		\item \textbf{\textbackslash src} 
			\begin{itemize}
				\item \textbf{index.jsx} Punto di entrata che effettua il render dei vari componenti React
				\item 	\textbf{\textbackslash app}
					\begin{itemize}
						\item \textbf{store.js} store setup
						\item \textbf{App.jsx} root dei componenti React
					\end{itemize}
				\item \textbf{\textbackslash common} contiene componenti generici e utility
			 	\item \textbf{\textbackslash features} contiene tutte le Feature folders
			 	\begin{itemize}
			 		\item \textbf{\textbackslash feature} Singola feature
			 		\begin{itemize}
			 			\item \textbf{featureSlice.js} contiene la logica del reducer e le azioni associate
			 			\item \textbf{Feature.jsx} componente React
			 			\item \textbf{Feature.css}
			 		\end{itemize}
			  \end{itemize}
			  \item \textbf{\textbackslash assets}
					\begin{itemize}
						\item \textbf{\textbackslash models} cartella contenete i vari modelli da utilizzare nel applicativo
						\item \textbf{\textbackslash img} cartella contenete icone ed immagini
					\end{itemize}
			\end{itemize}
\end{itemize}				
	
	\paragraph{Strumenti di sviluppo}
	Di seguito riportiamo gli strumenti utilizzati durante il processo di sviluppo:
		\begin{itemize}
			\item \textbf{React.js}: Libreria open-source per la creazione di interfacce utente in JavaScript;
			\item \textbf{Three.js}: Libreria JavaScript utilizzata per la realizzazione di contenuti 3D per il web, utilizza le API WebGL;
			\item \textbf{Node.js}: è un runtime system open source multipiattaforma orientato agli eventi per l'esecuzione di codice JavaScript;
			\item \textbf{Redux}: è una architettura per scrivere applicazioni web basate su 					React,  fornisce un modo semplice per centralizzare lo stato e la logica di 		un'applicazione web;
			\item \textbf{React three fiber}: è un React renderer per three.js , permette di costruire componenti riutilizzabili e indipendenti;
		\end{itemize}
		
	\paragraph{Ambiente di lavoro}
		Di seguito riportiamo gli strumenti che hanno definito il nostro ambiente di lavoro durante il processo di sviluppo.
		\begin{itemize}
			\item \textbf{Visual Studio Code}: Code editor scelto per sviluppare tutto il codice presente nel nostro progetto. Compatibile con Windows, MacOS e Linux;
		\end{itemize}
		
	\paragraph{Configurazione Ambiente di lavoro}
	La configurazione dell'ambiente di lavoro viene fatta da un componente del gruppo, che carica la cartella di lavoro configurata nel repo.  Successivamente gli altri componenti devono eseguire le seguenti istruzioni per mettersi in condizioni di lavorare.
	Per prima cosa ogni componente del gruppo deve installare Node.js e NPM attraverso package manager oppure al seguente link: 
	\begin{center}
\href{https://nodejs.org/en/download}{DownloadNode.js}
\end{center}
Facendo riferimento alla \textit{v18.16.0} o successive.  Per verificare che l'installazione sia andata a buon fine aprire il terminale ed utilizzare il comando \textit{node -v} e \textit{npm -v}. \\
Successivamente si deve entrare nella cartella di lavoro ottenuta dalla repo, aprire il terminale e utlizzare il comando \textbf{npm install} che installa tutte le dipendenze di progetto.


	 
	
	
	
	
	
			