import { Accessor, Document, GLTF, Primitive, Transform } from '@gltf-transform/core';
import { SetMap } from './utils.js';
/** Options for the {@link reorder} function. */
export interface ReorderOptions {
    /** MeshoptEncoder instance. */
    encoder: unknown;
    /**
     * Whether the order should be optimal for transmission size (recommended for Web)
     * or for GPU rendering performance. Default is 'size'.
     */
    target?: 'size' | 'performance';
}
/**
 * Optimizes {@link Mesh} {@link Primitive Primitives} for locality of reference. Choose whether
 * the order should be optimal for transmission size (recommended for Web) or for GPU rendering
 * performance. Requires a MeshoptEncoder instance from the Meshoptimizer library.
 *
 * Example:
 *
 * ```ts
 * import { MeshoptEncoder } from 'meshoptimizer';
 * import { reorder } from '@gltf-transform/functions';
 *
 * await MeshoptEncoder.ready;
 *
 * await document.transform(
 * 	reorder({encoder: MeshoptEncoder})
 * );
 * ```
 */
export declare function reorder(_options: ReorderOptions): Transform;
interface LayoutPlan {
    indicesToMode: Map<Accessor, GLTF.MeshPrimitiveMode>;
    indicesToAttributes: SetMap<Accessor, Accessor>;
    attributesToPrimitives: SetMap<Accessor, Primitive>;
}
/**
 * Constructs a plan for processing vertex streams, based on unique
 * index:attribute[] groups. Where different indices are used with the same
 * attributes, we'll end up splitting the primitives to not share attributes,
 * which appears to be consistent with the Meshopt implementation.
 */
export declare function createLayoutPlan(document: Document): LayoutPlan;
export {};
